
This plugin provides support for exposing RESTful interfaces.  This support is comprised of a mixin that controllers may use to provide default CRUD support, and a registry that facilitates support of custom representations. 

h4. REST Web Services - General Info

Over the past several years, REST has emerged to become the preferred approach to Web Services. 

{quote}
"The future of SOA is REST"
- Burton Group
{quote}

The Horizon architecture supports 'sharing of information' using the REpresentational State Transfer (REST) architectural style, coined by Joy Fielding within his dissertation of 2000 named 'Architectural Styles and the Design of Network-based Software Architecture'. It essentially describes how the 'web' works with respect to:
* resources 
* addressing for resources
* standard methods
* stateless, cacheable, layered protocol  

Where SOAP/WSDL-based Web Services provide a 'verb-oriented' approach to integration (e.g. a SOAP/WSDL Web Service may expose a 'createStudent' operation that could be used to create a student), REST web services enable a 'noun-oriented' approach to integration (e.g., a 'Student' _resource_ may be exposed, such that it can be created using an HTTP POST).  

Each _'resource'_ (often a 'model') is exposed using one or more _'representations'_ (e.g., JSON, XML complying to some XML Schema.) 

Unlike SOAP and the many WS-* standards, REST _uses_ the 'web' (HTTP protocol) to define a standard interface to all resources.  Consequently, all RESTful interfaces benefit from common methods, error codes, and headers. This contrasts with SOAP, that simply uses HTTP as one possible (and most common) transport protocol. 

Where SOAP exposes few URI endpoints (that each may support multiple operations), REST exposes many URI endpoints - one for each resource. 

The standard REST interface corresponds to CRUD, although it is important to understand that this standard interface need not be used solely for persistence of resources. 

Unlike SOAP Web Services that require the use of Web Services Description Language (WSDL) to learn 'how' to call the service, REST is 'simple'.  Given a URL of:  http://myschool.edu/banner/general/system/Student, you should already have a pretty good idea of how to use it based upon standard REST conventions.  That is, you know that using HTTP GET against this URL would return a list of students.  What you don't know is how to access the URI if it is secured, or what representations are supported - so REST does in practice need documentation, but this is often out-of-band. 

Based upon REST conventions, we can expect the following: 

|| HTTP VERB || URL || Invoked Controller Action ||
| HTTP GET  | http://myschool.edu/banner/api/general/system/Student       | 'list' |
| HTTP POST | http://myschool.edu/banner/api/general/system/Student       | 'create' |
| HTTP GET  | http://myschool.edu/banner/api/general/system/Student/12345 | 'show'   |
| HTTP PUT  | http://myschool.edu/banner/api/general/system/Student/12345 | 'update' |
| HTTP DELETE | http://myschool.edu/banner/api/general/system/Student/12345 | 'destroy' |

HTTP GET is idempotent - you can execute this as many times as you want with no long-term affect. This is an important benefit of REST over SOAP, which uses POST for everything - even if just reading information.  HTTP POST is not idempotent, and so does not guaranteed not to have any side effects... 

Before continuing the discussion of REST support within the Horizon architecture, it must be understood that while REST is generally preferred (due to its simplicity), SOAP web services continue to have their role - namely, SOAP based web services along with other WS-* standards are particularly applicable when solving 'process-oriented, brokered, distributed services' such at the often-shown 'travel agent' problem domain. WS-* Web Services support a more sophisticated (i.e., more granular) security model, as well as 'reliable messaging' (via WS-ReliableMessaging) - although this is more important when using SOAP as it uses only HTTP POST which is non-idempotent. Lastly, WS-* Web Services support both logical and physical transactions, which must be 'modeled' specifically when using REST. 


h4. Exposing RESTful Endpoints 

The banner-core plugin facilitates exposure of RESTful interfaces by providing a mixin for Grails Controllers.  This mixin provides CRUD controller actions that are exposed as the REST interface.  

A controller that mixes in the RestfulControllerMixin class will be given the controller actions shown above, and the ability to expose the model (aka resource) using JSON and XML resources IF those representations can be created using the default Grails Converters for JSON and XML. 

The mixin provides the ability to expose custom representations as well. This is needed when exposing a versioned API (e.g., that complies to a specific XML Schema), or when a Grails model is sufficiently complex that the default Grails converters are not able to create the desired JSON or XML. 

A RESTful interface may be provided using a minimal controller, shown below:
{code}
class FooController  {
    static List mixInRestActions = [ 'show', 'list', 'create', 'update', 'destroy' ]
    def fooService  // injected by Spring
}
{code}

The above controller will expose a RESTful interface for the 'Foo' model, supporting both JSON and XML using the default Grails converters.  

Of course, such a minimal controller may only be employed when the default converters can generate the desired JSON or XML, and when it is not deemed necessary to 'version' the representation.  If the model definition is modified (e.g., to add new properties), the representations will also be affected (e.g., to include those new properties). 

Often, this is an acceptable trade-off - sure, the representation may change, but this is balanced with the ease of use of the RESTful interface, and proper testing.

In any case, the mixin allows controllers to specify custom representations (by exposing a couple methods that will be called by the mixed-in actions).  In addition, and preferable, the banner-core plugin includes a 'ResourceRepresentationRegistry' Spring bean that is a registry used to support custom representations that are specified external to any controller.  This allows customers and SGHE developers to define representations without having to modify a controller.  

h4. Horizon Resource Representations

As discussed, a controller that mixes in the RestfulControllerMixin (by including the 'static List mixInRestActions' line shown above) will support both JSON and XML representations using the default Grails converters. While this may be sufficient for simpler models, and those that we use internally but are not anticipated to be used by customers, it is likely that most resources will require a custom representation.  This section provides an overview of how representations may be supported.

There are several configuration options to specify support for a custom representation.  First, the Config.groovy (or a configuration file included within Config.groovy) can be used to specify custom representations as shown below:
{code}
// ******************************************************************************
//
//                       +++ REST API SUPPORT +++
//
// ******************************************************************************
//
// Representations officially supported within Banner. Custom representations should not be added to this map,
// but should instead be added to a 'CustomRepresentationConfig.groovy' file, within a 'customRepresentationHandlerMap'
// that follows the same structure as the map below.  Please see the configuration location information earlier in
// this file regarding options for externalizing this 'CustomRepresentationConfig' configuration.
//
// Following are the 'built-in' representations supported by SunGard Higher Education. 
// Note that representation support may be in the
// form of custom handler classes, or may be implemented in-line within the map below via closures.  See the
// banner-core plugin test-banner-core test application's Config.groovy for an example of in-lining representation support.
//
bannerRepresentationHandlerMap = [
    "application/vnd.sungardhe.banner.general.v0.01+xml": 
        [ "College": "net.hedtech.banner.general.system.CollegeRepresentationHandler_v0_01",
          // next Model supported goes here
        ],
    "application/vnd.sungardhe.banner.general.v0.02+xml": 
        [ "College": "net.hedtech.banner.general.system.CollegeRepresentationHandler_v0_02",
        // next Model supported goes here
        ],                                                    ],
    // The next MIME type(s) should be added here

]
{code} 

The above registers a custom handler for the specified custom MIME type and model class.  The support shown above is in the form of a 'ResourceHandler' implementation (a Groovy class) that will be loaded dynamically. 

By exposing such a configuration, there is flexibility in how the custom support is implemented. What is required is that for a given MIME type and model class, a handler is returned when one can support that MIME type and model type.  That same handler implementation could handle other MIME types, or even other models - or it could be a unique implementation (such as the one referenced in the configuration above).

The ResourceHandler interface defines a few important methods - one to retrieve a custom 'ParamsExtractor' implementation and a couple of methods to retrieve custom 'ResourceRepresentationBuilder' implementations that may be used to build representations for a single model and for a collection of models.  

These interfaces are shown below. First, here is the 'ResourceRepresentationHandler':
{code}
public ParamsExtractor paramsExtractor();

public RepresentationBuilder singleBuilder(); 

public RepresentationBuilder collectionBuilder();
{code}

The handler's paramsExtractor() returns a ParamsExtractor:
{code}
/**
 * Extracts a map of name-value pairs representing the properties of the supported resource (aka model).
 * @param request the HTTP servlet request object representing the current request
 * @return Map a map of properties that will be added to the Grails 'params' object
 */
public Map extractParams( HttpServletRequest request );
{code}

The handler's singleBuilder() and collectionBuilder() methods each return a ResourceRepresentationBuilder:
{code}
/**
 * Builds and returns a representation for the supplied content. This representation is
 * normally a String, although it may also be a Map (hence the 'Object' return type).
 * @param content a Map holding source content to be used when creating the representation
 * @return Object a 'String' or 'Map' representation of the resource that may be rendered to the client
 */
public Object buildRepresentation( Map content );
{code}

Again, the actual implementation may be flexible, supporting multiple models and multiple representations or supporting only one model and one representation.

In addition, we can also leverage the 'groovy' ability to coerce a closure into an interface.  This allows us to support in-line configuration as well.  Here is an example, from the test-banner-core test application's Config.groovy (note some content omitted for brevity):
{code}
bannerRepresentationHandlerMap =
    [ "application/vnd.sungardhe.student.v0.02+xml":
        [ "Foo": // prefer to use fully qualified class names, but short names are also handled 
            [ paramsExtractor:  { request ->
                    def xml = request.XML.Foo[0]
                    def props = [:]
                    if (xml.@id?.text())                           props.id                 = xml.@id.toInteger()
                    if (xml.@lastModifiedBy?.text())               props.lastModifiedBy     = "${xml.@lastModifiedBy.text()}"
                    if (xml.@lastModified?.text())                 props.lastModified       = xml.@lastModified.text()
                    if (xml.@dataOrigin?.text())                   props.dataOrigin         = "${xml.@dataOrigin.text()}"
                    if (xml.@optimisticLockVersion?.text())        props.version    = xml.@optimisticLockVersion.toInteger()
                
                    if (xml.Code?.text())                          props.code               = "${xml.Code.text()}"
                    if (xml.Description?.text())                   props.description        = "${xml.Description.text()}"
                
                    if (xml.AddressStreetLine1?.text())            props.addressStreetLine1 = xml.AddressStreetLine1?.text()
                    if (xml.AddressStreetLine2?.text())            props.addressStreetLine2 = xml.AddressStreetLine2?.text()
                    if (xml.AddressStreetLine3?.text())            props.addressStreetLine3 = xml.AddressStreetLine3?.text()
                    if (xml.AddressStreetLine4?.text())            props.addressStreetLine4 = xml.AddressStreetLine4?.text()
                    if (xml.HouseNumber?.text())                   props.houseNumber        = xml.HouseNumber?.text()
                
                    if (xml.AddressCity?.text())                   props.addressCity        = xml.AddressCity?.text()
                    if (xml.AddressState?.text())                  props.addressState       = xml.AddressState?.text()
                    if (xml.AddressCountry?.text())                props.addressCountry     = xml.AddressCountry?.text()
                    if (xml.AddressZipCode?.text())                props.addressZipCode     = xml.AddressZipCode?.text()
                
                    if (xml.DistrictDivision?.text())              props.districtDivision   = xml.DistrictDivision?.text()
                    props
                },
              singleBuilder: { renderDataMap -> [ template: "/foo/single.v1.0.xml",
                                                   model: [ foo: renderDataMap.data, refBase: renderDataMap.refBase ] ] },
              collectionBuilder: { renderDataMap -> [ template: "/foo/list.v1.0.xml",
                                                   model: [ fooList: renderDataMap.data, totalCount: renderDataMap.totalCount,
                                                            refBase: renderDataMap.refBase ] ] }
            ], // end Foo support

            // next model supported by this same MIME type should go here...
         ],

      // This second example to support v0.03 for Foo use an external groovy file 
      // - please make sure the groovy file is available on the classpath
      "application/vnd.sungardhe.student.v0.03+xml":
          [ "Foo": "net.hedtech.banner.testing.FooMarkupBuilderBasedRepresentationHandler" ],

      // next MIME type would go here
]
{code}

Note that while the banner-core plugin facilitates exposure of RESTful interfaces (via the mixin, the resource representation registry, and interfaces for custom params extraction and representation building), each project must establish it's own URI mapping.  It is highly recommended, however, that each project simply include the following within it's URLMappings.groovy:
{code}
// ******************************************************************************
//
//                       +++ RESTful URL MAPPINGS +++
//
// ******************************************************************************

        "/api/$controller" { 
            action = [ GET: "list", POST: "create" ]
        }

        "/api/$controller/$id" { 
            action = [ GET: "show", PUT: "update", DELETE: "destroy" ]
        }

{code}

In this mapping, URI's beginning with '/api/' can be easily identified as 'RESTful' endpoints, and can be mapped to the appropriate controller and action. Also, this convention facilitates protection of the 'api' URIs using 'Basic Authentication'. 

\\

h4. Consuming RESTful Endpoints 

Consuming a RESTful web service is quite easy using Groovy and the [RestClient|http://groovy.codehaus.org/modules/http-builder/doc/rest.html] library.  In addition, the 'Functional Test' plugin provides similar built-in support for testing the RESTful endpoints. 

While this library is very capable and may be used near-term if needed, as our needs become more advanced we will likely provide an additional abstraction layer and additional infrastructure (e.g., the [Camel|http://camel.apache.org/] routing and mediation engine provides a nice Groovy DSL to implement routing logic).   

\\
